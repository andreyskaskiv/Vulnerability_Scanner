import re
import time
import urllib.parse
import urllib.parse as urlparse
from random import choice

import requests
from bs4 import BeautifulSoup
from colorama import init, Fore, Style

from handlers.decode_handler import decode_values
from handlers.file_handler import write_links_to_file, write_data_to_file, write_forms_to_file
from handlers.utils import setup_logger
from vulnerability_check.check_for_vulnerability_to_command_exec import test_command_execution_in_form
from vulnerability_check.check_for_vulnerability_to_csrf import test_csrf_injection_in_form
from vulnerability_check.check_for_vulnerability_to_html_injection import test_html_injection_in_form
from vulnerability_check.check_for_vulnerability_to_sql_injection import test_sql_injection_in_form
from vulnerability_check.check_for_vulnerability_to_xss import (test_xss_in_form, test_xss_in_link,
                                                                test_xss_in_link_prefix, test_xss_in_header)

headers = {
    'User-Agent': choice(list(map(str.rstrip, open("_user_agent_pc.txt").readlines()))),
    'Accept': 'text/html,application/xhtml',
}


class Scanner:
    def __init__(self, url: str, ignore_links: list[str]):
        """
        :param url: target url
        :param ignore_links: a list with ignored links, for example, so as not to lose the session
        """
        init()
        self.logger = setup_logger()
        self.request_count = 0
        self.start_time = time.time()

        self.session = requests.Session()
        self.target_url = url
        self.ignore_links = ignore_links

        self.target_links = []
        self.target_forms_XSS = []
        self.target_links_XSS = []
        self.target_links_XSS_HEADER = []
        self.target_forms_command_exec = []
        self.target_forms_html_injection = []
        self.target_forms_sql_injection = []
        self.target_forms_csrf_injection = []

        self.target_forms_not_vulnerable = []

    def login(self, login_form, data_login):
        self.session.headers.update(headers)
        response = self.session.post(login_form, data=data_login)
        self.logger.info(f"{response.request.headers}")
        # self.logger.info(f"{requests.utils.dict_from_cookiejar(self.session.cookies).__str__()}")

    def login_with_cookie(self, login_form, cookies):
        # self.session.headers.update(headers)
        self.session.cookies.update(cookies)
        response = self.session.get(login_form)
        self.logger.info(f"{response.request.headers}")

    def is_logged_in_via_cookies(self, data_login):
        username = data_login['username']
        if self.session.cookies.get(username):
            return True
        return False

    def is_logged_in_via_session_data(self, data_login):
        username = data_login['username']
        if username in self.session:
            return True
        return False

    def is_logged_in_via_auth_token(self, data_login):
        auth_token = data_login['auth_token']
        if auth_token in self.session.headers:
            return True
        return False

    def extract_links_from(self, url: str):
        """Extract links from the target site using regular expressions"""
        response = self.session.get(url)
        answer = decode_values(response.content)
        return re.findall('(?:href=")(.*?)"', answer)

    def crawl(self, url=None):
        """Link Refactor. Removes duplicates. Removes links not related to the target site."""
        if url is None:
            url = self.target_url
            if url not in self.ignore_links and url not in self.target_links:
                self.target_links.append(url)
                print(url)

        href_links = self.extract_links_from(url)
        for link in href_links:
            link = urllib.parse.urljoin(url, link)

            if "#" in link:
                link = link.split("#")[0]

            if (self.target_url in link
                    and link not in self.target_links
                    and link not in self.ignore_links):
                self.target_links.append(link)
                print(link)

                self.crawl(link)

    def extract_forms(self, url: str):
        """This function is used to extract all the forms from a webpage specified by the input URL."""
        response = self.session.get(url)
        parsed_html = BeautifulSoup(response.content, features='lxml')  # features='html.parser' features='lxml'
        return parsed_html.findAll("form")

    def submit_form(self, form, value: dict | str, url: str):
        """
        Extract all required attributes from forms. Fill out and submit the form
        :param header_payload:
        :param form: Specify the form you want to submit
        :param value: The value we want to set for the inputs in this form
        :param url: Url address of the page from which we retrieved this form
        :return:
        """

        action = form.get("action")
        post_url = urlparse.urljoin(url, action)
        # print(f" ====> {post_url}")
        method = form.get("method")

        inputs_list = form.findAll("input")  # search all tag

        post_data = {}
        for input in inputs_list:
            input_name = input.get("name")  # extract attribute
            input_type = input.get("type")
            input_value = input.get("value")

            if input_type == "text" or not input_type:
                input_value = value

            if input_name:
                post_data[input_name] = input_value

            post_data[input_name] = input_value

        if method == 'post':
            # print(f" \n====> post_url: {post_url} | post_data: {post_data}")
            return self.session.post(post_url, data=post_data)

        # print(f" \n====> get_url: {post_url} | post_data: {post_data}")
        return self.session.get(post_url, params=post_data)

    def run_scanner(self, case: set[str], scanning_level: list[str], req_per_minute: int):
        """Check each link in the target_links list, extract forms from those links.
         Check forms and links for vulnerabilities"""

        for link in self.target_links:

            if "xss_in_header" in case:
                print(f"[ ] Testing XSS in header: {link}")
                is_vulnerable_to_xss = test_xss_in_header(self, url=link, req_per_minute=req_per_minute)
                if is_vulnerable_to_xss:
                    self.target_links_XSS_HEADER.append((link, is_vulnerable_to_xss))
                    self.show_info(link=link, is_vulnerable_to=is_vulnerable_to_xss)

            if "xss_in_link" in case:
                if link.endswith('/'):
                    """Add and call a method if a LINK vulnerability is found"""
                    print(f"[ ] Testing Link: {link}")
                    is_vulnerable_to_xss = test_xss_in_link(self, link,
                                                            level=scanning_level, req_per_minute=req_per_minute)
                    if is_vulnerable_to_xss:
                        self.target_links_XSS.append((link, is_vulnerable_to_xss))
                        self.show_info(link=link, is_vulnerable_to=is_vulnerable_to_xss)

                elif re.match(r'^.*=\d+$', link):
                    prefix = f"{link.split('=')[0]}="
                    print(f"[ ] Testing Link-prefix: {prefix}")
                    is_vulnerable_to_xss = test_xss_in_link_prefix(self, prefix,
                                                                   level=scanning_level, req_per_minute=req_per_minute)
                    if is_vulnerable_to_xss:
                        self.target_links_XSS.append((prefix, is_vulnerable_to_xss))
                        self.show_info(link=prefix, is_vulnerable_to=is_vulnerable_to_xss)
                else:
                    prefix = f"{link}="
                    print(f"[ ] Testing Link-other: {prefix}")

                    is_vulnerable_to_xss = test_xss_in_link_prefix(self, prefix,
                                                                   level=scanning_level, req_per_minute=req_per_minute)
                    if is_vulnerable_to_xss:
                        self.target_links_XSS.append((prefix, is_vulnerable_to_xss))
                        self.show_info(link=prefix, is_vulnerable_to=is_vulnerable_to_xss)

            forms = self.extract_forms(link)

            for form in forms:

                if "xss_in_form" in case:
                    print(f"[ ] XSS Testing Form in: {link}")
                    is_vulnerable_to_xss = test_xss_in_form(self, form=form, url=link,
                                                            level=scanning_level, req_per_minute=req_per_minute)
                    if is_vulnerable_to_xss:
                        self.target_forms_XSS.append((link, form, is_vulnerable_to_xss))
                        self.show_info(link=link, is_vulnerable_to=is_vulnerable_to_xss, form=form)
                    else:
                        if not any(form == existing_form for _, existing_form in self.target_forms_not_vulnerable):
                            self.target_forms_not_vulnerable.append((link, form))

                if "comex" in case:
                    print(f"[ ] COMMAND EXEC Testing Form in: {link}")
                    is_vulnerable_to_command_exec = test_command_execution_in_form(self, form=form, url=link,
                                                                                   level=scanning_level,
                                                                                   req_per_minute=req_per_minute)
                    if is_vulnerable_to_command_exec:
                        self.target_forms_command_exec.append((link, form, is_vulnerable_to_command_exec))
                        self.show_info(link=link, is_vulnerable_to=is_vulnerable_to_command_exec, form=form)
                    else:
                        if not any(form == existing_form for _, existing_form in self.target_forms_not_vulnerable):
                            self.target_forms_not_vulnerable.append((link, form))

                if "html" in case:
                    print(f"[ ] HTML Testing Form in: {link}")
                    is_vulnerable_to_html = test_html_injection_in_form(self, form=form, url=link)
                    if is_vulnerable_to_html:
                        self.target_forms_html_injection.append((link, form, is_vulnerable_to_html))
                        self.show_info(link=link, is_vulnerable_to=is_vulnerable_to_html, form=form)
                    else:
                        if not any(form == existing_form for _, existing_form in self.target_forms_not_vulnerable):
                            self.target_forms_not_vulnerable.append((link, form))

                if "sql" in case:
                    print(f"[ ] SQL Testing Form in: {link}")
                    is_vulnerable_to_sql_injection = test_sql_injection_in_form(self, form=form, url=link)
                    if is_vulnerable_to_sql_injection:
                        self.target_forms_sql_injection.append((link, form, is_vulnerable_to_sql_injection))
                        self.show_info(link=link, is_vulnerable_to=is_vulnerable_to_sql_injection, form=form)
                    else:
                        if not any(form == existing_form for _, existing_form in self.target_forms_not_vulnerable):
                            self.target_forms_not_vulnerable.append((link, form))

                if "csrf" in case:
                    print(f"[ ] CSRF Testing Form in: {link}")
                    is_vulnerable_to_csrf_injection = test_csrf_injection_in_form(self, form=form, url=link)
                    if is_vulnerable_to_csrf_injection:
                        self.target_forms_csrf_injection.append((link, form, is_vulnerable_to_csrf_injection))
                        self.show_info(link=link, is_vulnerable_to=is_vulnerable_to_csrf_injection, form=form)
                    else:
                        if not any(form == existing_form for _, existing_form in self.target_forms_not_vulnerable):
                            self.target_forms_not_vulnerable.append((link, form))

    @classmethod
    def show_info(cls, link, is_vulnerable_to=None, form=None):
        if is_vulnerable_to:
            print(f"{Fore.CYAN}{Style.BRIGHT}\n[+] ðŸ’‰ Discovered in: {link}{Style.RESET_ALL}\n")
            print(f"{Fore.YELLOW}[***] ðŸ’‰ Payload: \n\"{is_vulnerable_to}\"{Style.RESET_ALL}\n")
            if form:
                print(f"{Fore.GREEN}Form: {Style.RESET_ALL} \n{form}")
            print(f"{'=' * 80}\n\n")

    def requests_per_minute(self):
        elapsed_time = time.time() - self.start_time
        req_per_min = int(self.request_count / (elapsed_time / 60))
        self.logger.info(f"\nThe vulnerability scanner ran for {round(elapsed_time, 2)} seconds."
                         f"The estimated query({self.request_count}) execution time per minute is {req_per_min}.")

    def get_all_lists(self):
        return {
            "target_forms_XSS": self.target_forms_XSS,
            "target_links_XSS": self.target_links_XSS,
            "target_links_XSS_HEADER": self.target_links_XSS_HEADER,
            "target_forms_command_exec": self.target_forms_command_exec,
            "target_forms_html_injection": self.target_forms_html_injection,
            "target_forms_sql_injection": self.target_forms_sql_injection,
            "target_forms_csrf_injection": self.target_forms_csrf_injection,
            "target_forms_not_vulnerable": self.target_forms_not_vulnerable,
        }

    def write_target_links(self, write_file: str):
        if self.target_links:
            print(write_links_to_file(self.target_links, write_file))